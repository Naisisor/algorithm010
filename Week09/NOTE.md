# Table of Contents

- [Table of Contents](#table-of-contents)
  - [第 9 周](#第-9-周)
    - [第 19 课 | 高级动态规划](#第-19-课--高级动态规划)
      - [动态规划、状态转移方程串讲](#动态规划状态转移方程串讲)
      - [高级动态规划题目详解](#高级动态规划题目详解)
    - [第 20 课 | 字符串算法](#第-20-课--字符串算法)
      - [字符串基础知识和引申问题](#字符串基础知识和引申问题)
      - [高级字符串算法](#高级字符串算法)
      - [字符串匹配算法](#字符串匹配算法)
        - [Rabin-Karp 算法](#rabin-karp-算法)
        - [KMP 算法](#kmp-算法)
        - [参考链接](#参考链接)

## 第 9 周

### 第 19 课 | 高级动态规划

#### 动态规划、状态转移方程串讲

#### 高级动态规划题目详解

### 第 20 课 | 字符串算法

#### 字符串基础知识和引申问题

#### 高级字符串算法

#### 字符串匹配算法

##### Rabin-Karp 算法

在朴素算法中，我们需要挨个比较所有字符，才知道目标字符串中是否包含 子串。那么， 是否有别的方法可以用来判断目标字符串是否包含子串呢?
答案是肯定的，确实存在一种更快的方法。为了避免挨个字符对目标字符串 和子串进行比较， 我们可以尝试一次性判断两者是否相等。因此，我们需 要一个好的哈希函数(hash function)。 通过哈希函数，我们可以算出子 串的哈希值，然后将它和目标字符串中的子串的哈希值进行比较。 这个新 方法在速度上比暴力法有显著提升。

Rabin-Karp 算法的思想:

1. 假设子串的长度为 M (pat)，目标字符串的长度为 N (txt)
2. 计算子串的 hash 值 hash_pat
3. 计算目标字符串 txt 中每个长度为 M 的子串的 hash 值(共需要计算 N-M+1 次)
4. 比较 hash 值:如果 hash 值不同，字符串必然不匹配; 如果 hash 值相同， 还需要使用朴素算法再次判断

##### KMP 算法

KMP 算法(Knuth-Morris-Pratt)的思想就是，当子串与目标字符串不匹配时， 其实你已经知道了前面已经匹配成功那 一部分的字符(包括子串与目标字符 串)。以阮一峰的文章为例，当空格与 D 不匹配时，你其实 知道前面六个字符是 “ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把“搜索位
置” 移回已经比较过的位置，继续把它向后移，这样就提高了效率。

##### 参考链接

1. [KMP 字符串匹配算法 1](https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171)
2. [字符串匹配的 KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)
